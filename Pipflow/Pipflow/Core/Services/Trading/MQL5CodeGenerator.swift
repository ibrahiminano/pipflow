//
//  MQL5CodeGenerator.swift
//  Pipflow
//
//  Generates MQL5 code from strategy components
//

import Foundation

class MQL5CodeGenerator {
    static let shared = MQL5CodeGenerator()
    
    private init() {}
    
    // MARK: - Generate Expert Advisor
    
    func generateExpertAdvisor(from strategy: ParsedStrategy, name: String) -> String {
        var code = generateHeader(name: name, description: strategy.originalText)
        code += generateInputParameters(strategy: strategy)
        code += generateGlobalVariables(strategy: strategy)
        code += generateInitFunction()
        code += generateDeinitFunction()
        code += generateOnTickFunction(strategy: strategy)
        code += generateHelperFunctions(strategy: strategy)
        
        // Add signal functions
        code += generateSignalFunctions(conditions: strategy.entryConditions)
        
        return code
    }
    
    func generateAndValidate(from strategy: ParsedStrategy, name: String) -> (code: String, validation: MQL5SyntaxValidator.ValidationResult) {
        let code = generateExpertAdvisor(from: strategy, name: name)
        let validation = MQL5SyntaxValidator.shared.validateMQL5Code(code)
        return (code, validation)
    }
    
    // MARK: - Code Sections
    
    private func generateHeader(name: String, description: String) -> String {
        return """
        //+------------------------------------------------------------------+
        //|                                                    \(name).mq5    |
        //|                                        Generated by Pipflow AI   |
        //|                                         https://pipflow.ai       |
        //+------------------------------------------------------------------+
        #property copyright "Pipflow AI"
        #property link      "https://pipflow.ai"
        #property version   "1.00"
        #property description "\(description)"
        
        #include <Trade\\Trade.mqh>
        #include <Expert\\Money\\MoneyFixedRisk.mqh>
        
        """
    }
    
    private func generateInputParameters(strategy: ParsedStrategy) -> String {
        var params = """
        //--- Input parameters
        input group "Trading Settings"
        input double   InpLotSize = 0.01;           // Lot Size
        input int      InpMagicNumber = 777888;     // Magic Number
        input string   InpComment = "Pipflow AI";   // Trade Comment
        
        input group "Risk Management"
        """
        
        // Add risk parameters
        for rule in strategy.riskRules {
            switch rule.type {
            case .riskPerTrade:
                params += """
                input double   InpRiskPercent = \(rule.value);     // Risk Per Trade (%)
                """
            case .maxPositions:
                params += """
                input int      InpMaxPositions = \(Int(rule.value));      // Max Open Positions
                """
            case .maxDrawdown:
                params += """
                input double   InpMaxDrawdown = \(rule.value);      // Max Drawdown (%)
                """
            default:
                break
            }
        }
        
        // Add indicator parameters based on conditions
        if hasRSI(in: strategy.entryConditions) {
            params += """
            
            input group "RSI Settings"
            input int      InpRSIPeriod = 14;          // RSI Period
            input double   InpRSIOverbought = 70;      // RSI Overbought Level
            input double   InpRSIOversold = 30;        // RSI Oversold Level
            """
        }
        
        if hasMA(in: strategy.entryConditions) {
            params += """
            
            input group "Moving Average Settings"
            input int      InpFastMA = 20;             // Fast MA Period
            input int      InpSlowMA = 50;             // Slow MA Period
            input ENUM_MA_METHOD InpMAMethod = MODE_SMA; // MA Method
            """
        }
        
        // Add exit parameters
        params += """
        
        input group "Exit Settings"
        input double   InpStopLoss = 50;           // Stop Loss (pips)
        input double   InpTakeProfit = 100;        // Take Profit (pips)
        input bool     InpUseTrailing = false;     // Use Trailing Stop
        input double   InpTrailingStart = 30;      // Trailing Start (pips)
        input double   InpTrailingStep = 10;       // Trailing Step (pips)
        
        """
        
        return params
    }
    
    private func generateGlobalVariables(strategy: ParsedStrategy) -> String {
        var globals = """
        //--- Global variables
        CTrade trade;
        CPositionInfo position;
        COrderInfo order;
        CSymbolInfo symbol;
        
        // Indicator handles
        """
        
        if hasRSI(in: strategy.entryConditions) {
            globals += "int rsi_handle;\n"
        }
        
        if hasMA(in: strategy.entryConditions) {
            globals += "int fast_ma_handle;\n"
            globals += "int slow_ma_handle;\n"
        }
        
        globals += """
        
        // Buffers
        double rsi_buffer[];
        double fast_ma_buffer[];
        double slow_ma_buffer[];
        
        // Trading variables
        double point;
        double sl_points, tp_points;
        datetime last_trade_time = 0;
        
        """
        
        return globals
    }
    
    private func generateInitFunction() -> String {
        return """
        //+------------------------------------------------------------------+
        //| Expert initialization function                                    |
        //+------------------------------------------------------------------+
        int OnInit()
        {
            // Initialize symbol
            if(!symbol.Name(Symbol()))
            {
                Print("Failed to initialize symbol");
                return INIT_FAILED;
            }
            
            // Set magic number
            trade.SetExpertMagicNumber(InpMagicNumber);
            
            // Calculate points
            point = symbol.Point();
            sl_points = InpStopLoss * point * 10;
            tp_points = InpTakeProfit * point * 10;
            
            // Initialize indicators
            rsi_handle = iRSI(Symbol(), PERIOD_CURRENT, InpRSIPeriod, PRICE_CLOSE);
            if(rsi_handle == INVALID_HANDLE)
            {
                Print("Failed to create RSI indicator");
                return INIT_FAILED;
            }
            
            // Set arrays as series
            ArraySetAsSeries(rsi_buffer, true);
            ArraySetAsSeries(fast_ma_buffer, true);
            ArraySetAsSeries(slow_ma_buffer, true);
            
            return INIT_SUCCEEDED;
        }
        
        """
    }
    
    private func generateDeinitFunction() -> String {
        return """
        //+------------------------------------------------------------------+
        //| Expert deinitialization function                                  |
        //+------------------------------------------------------------------+
        void OnDeinit(const int reason)
        {
            // Release indicator handles
            if(rsi_handle != INVALID_HANDLE)
                IndicatorRelease(rsi_handle);
        }
        
        """
    }
    
    private func generateOnTickFunction(strategy: ParsedStrategy) -> String {
        var code = """
        //+------------------------------------------------------------------+
        //| Expert tick function                                              |
        //+------------------------------------------------------------------+
        void OnTick()
        {
            // Check if we can trade
            if(!CanTrade())
                return;
            
            // Get indicator values
            if(!GetIndicatorValues())
                return;
            
            // Count open positions
            int positions = CountPositions();
            
            // Check for entry signals
            if(positions < InpMaxPositions)
            {
        """
        
        // Generate entry logic based on conditions
        code += generateEntryLogic(conditions: strategy.entryConditions)
        
        code += """
            }
            
            // Check for exit signals
            if(positions > 0)
            {
                CheckExitSignals();
            }
            
            // Update trailing stops
            if(InpUseTrailing)
            {
                UpdateTrailingStops();
            }
        }
        
        """
        
        return code
    }
    
    private func generateHelperFunctions(strategy: ParsedStrategy) -> String {
        return """
        //+------------------------------------------------------------------+
        //| Check if we can trade                                            |
        //+------------------------------------------------------------------+
        bool CanTrade()
        {
            // Check if trade is allowed
            if(!TerminalInfoInteger(TERMINAL_TRADE_ALLOWED))
                return false;
            
            // Check connection
            if(!TerminalInfoInteger(TERMINAL_CONNECTED))
                return false;
            
            // Check if market is open
            if(!symbol.IsTradeMode())
                return false;
            
            // Check spread
            if(symbol.Spread() > 50)
                return false;
            
            return true;
        }
        
        //+------------------------------------------------------------------+
        //| Get indicator values                                             |
        //+------------------------------------------------------------------+
        bool GetIndicatorValues()
        {
            // Copy RSI values
            if(CopyBuffer(rsi_handle, 0, 0, 3, rsi_buffer) != 3)
                return false;
            
            return true;
        }
        
        //+------------------------------------------------------------------+
        //| Count open positions                                              |
        //+------------------------------------------------------------------+
        int CountPositions()
        {
            int count = 0;
            
            for(int i = PositionsTotal() - 1; i >= 0; i--)
            {
                if(position.SelectByIndex(i))
                {
                    if(position.Symbol() == Symbol() && position.Magic() == InpMagicNumber)
                        count++;
                }
            }
            
            return count;
        }
        
        //+------------------------------------------------------------------+
        //| Open position                                                     |
        //+------------------------------------------------------------------+
        bool OpenPosition(ENUM_ORDER_TYPE type)
        {
            double price = (type == ORDER_TYPE_BUY) ? symbol.Ask() : symbol.Bid();
            double sl = (type == ORDER_TYPE_BUY) ? price - sl_points : price + sl_points;
            double tp = (type == ORDER_TYPE_BUY) ? price + tp_points : price - tp_points;
            
            // Calculate lot size based on risk
            double lots = CalculateLotSize(MathAbs(price - sl));
            
            // Open position
            if(trade.PositionOpen(Symbol(), type, lots, price, sl, tp, InpComment))
            {
                last_trade_time = TimeCurrent();
                return true;
            }
            
            return false;
        }
        
        //+------------------------------------------------------------------+
        //| Calculate lot size based on risk                                 |
        //+------------------------------------------------------------------+
        double CalculateLotSize(double sl_distance)
        {
            double risk_amount = AccountInfoDouble(ACCOUNT_BALANCE) * InpRiskPercent / 100;
            double tick_value = symbol.TickValue();
            double lots = risk_amount / (sl_distance / symbol.Point() * tick_value);
            
            // Normalize lot size
            lots = NormalizeDouble(lots, 2);
            
            // Check limits
            double min_lot = symbol.LotsMin();
            double max_lot = symbol.LotsMax();
            
            if(lots < min_lot) lots = min_lot;
            if(lots > max_lot) lots = max_lot;
            
            return lots;
        }
        
        //+------------------------------------------------------------------+
        //| Check exit signals                                                |
        //+------------------------------------------------------------------+
        void CheckExitSignals()
        {
            for(int i = PositionsTotal() - 1; i >= 0; i--)
            {
                if(position.SelectByIndex(i))
                {
                    if(position.Symbol() == Symbol() && position.Magic() == InpMagicNumber)
                    {
                        // Add exit logic here based on strategy
                        
                        // Example: Close on opposite signal
                        if(position.PositionType() == POSITION_TYPE_BUY && ShouldSell())
                        {
                            trade.PositionClose(position.Ticket());
                        }
                        else if(position.PositionType() == POSITION_TYPE_SELL && ShouldBuy())
                        {
                            trade.PositionClose(position.Ticket());
                        }
                    }
                }
            }
        }
        
        //+------------------------------------------------------------------+
        //| Update trailing stops                                             |
        //+------------------------------------------------------------------+
        void UpdateTrailingStops()
        {
            for(int i = PositionsTotal() - 1; i >= 0; i--)
            {
                if(position.SelectByIndex(i))
                {
                    if(position.Symbol() == Symbol() && position.Magic() == InpMagicNumber)
                    {
                        double current_sl = position.StopLoss();
                        double current_price = position.PriceCurrent();
                        double open_price = position.PriceOpen();
                        
                        if(position.PositionType() == POSITION_TYPE_BUY)
                        {
                            if(current_price - open_price >= InpTrailingStart * point * 10)
                            {
                                double new_sl = current_price - InpTrailingStep * point * 10;
                                if(new_sl > current_sl)
                                {
                                    trade.PositionModify(position.Ticket(), new_sl, position.TakeProfit());
                                }
                            }
                        }
                        else // SELL
                        {
                            if(open_price - current_price >= InpTrailingStart * point * 10)
                            {
                                double new_sl = current_price + InpTrailingStep * point * 10;
                                if(new_sl < current_sl || current_sl == 0)
                                {
                                    trade.PositionModify(position.Ticket(), new_sl, position.TakeProfit());
                                }
                            }
                        }
                    }
                }
            }
        }
        
        """
    }
    
    // MARK: - Entry Logic Generation
    
    private func generateEntryLogic(conditions: [StrategyCondition]) -> String {
        var buyConditions: [String] = []
        var sellConditions: [String] = []
        
        for condition in conditions {
            if case .entry(let entryType) = condition.type {
                switch entryType {
                case .rsiOversold:
                    buyConditions.append("rsi_buffer[1] < InpRSIOversold && rsi_buffer[0] > InpRSIOversold")
                case .rsiOverbought:
                    sellConditions.append("rsi_buffer[1] > InpRSIOverbought && rsi_buffer[0] < InpRSIOverbought")
                case .crossAbove:
                    if condition.parameters.count >= 2 {
                        buyConditions.append("// \(condition.parameters[0]) crosses above \(condition.parameters[1])")
                    }
                case .crossBelow:
                    if condition.parameters.count >= 2 {
                        sellConditions.append("// \(condition.parameters[0]) crosses below \(condition.parameters[1])")
                    }
                default:
                    break
                }
            }
        }
        
        // Default conditions if none specified
        if buyConditions.isEmpty {
            buyConditions.append("rsi_buffer[0] < InpRSIOversold")
        }
        if sellConditions.isEmpty {
            sellConditions.append("rsi_buffer[0] > InpRSIOverbought")
        }
        
        return """
                if(ShouldBuy())
                {
                    OpenPosition(ORDER_TYPE_BUY);
                }
                else if(ShouldSell())
                {
                    OpenPosition(ORDER_TYPE_SELL);
                }
        """
    }
    
    // MARK: - Helper Methods
    
    private func hasRSI(in conditions: [StrategyCondition]) -> Bool {
        return conditions.contains { condition in
            if case .entry(let type) = condition.type {
                return type == .rsiOversold || type == .rsiOverbought
            }
            return false
        }
    }
    
    private func hasMA(in conditions: [StrategyCondition]) -> Bool {
        return conditions.contains { condition in
            condition.parameters.contains { $0.lowercased().contains("ma") || $0.lowercased().contains("moving average") }
        }
    }
    
    // MARK: - Signal Functions
    
    func generateSignalFunctions(conditions: [StrategyCondition]) -> String {
        var buyConditions: [String] = []
        var sellConditions: [String] = []
        
        // Extract conditions
        for condition in conditions {
            if case .entry(let entryType) = condition.type {
                switch entryType {
                case .rsiOversold:
                    buyConditions.append("rsi_buffer[0] < InpRSIOversold")
                case .rsiOverbought:
                    sellConditions.append("rsi_buffer[0] > InpRSIOverbought")
                default:
                    break
                }
            }
        }
        
        return """
        //+------------------------------------------------------------------+
        //| Check for buy signal                                              |
        //+------------------------------------------------------------------+
        bool ShouldBuy()
        {
            // Check time filter
            if(TimeCurrent() - last_trade_time < 300) // 5 minute cooldown
                return false;
            
            // Buy conditions
            return \(buyConditions.joined(separator: " && "));
        }
        
        //+------------------------------------------------------------------+
        //| Check for sell signal                                             |
        //+------------------------------------------------------------------+
        bool ShouldSell()
        {
            // Check time filter
            if(TimeCurrent() - last_trade_time < 300) // 5 minute cooldown
                return false;
            
            // Sell conditions
            return \(sellConditions.joined(separator: " && "));
        }
        """
    }
}

// MARK: - Strategy Templates

extension MQL5CodeGenerator {
    
    func generateFromTemplate(_ template: MQL5StrategyTemplate, customizations: [String: Any]) -> String {
        switch template {
        case .scalping:
            return generateScalpingTemplate(customizations)
        case .trending:
            return generateTrendingTemplate(customizations)
        case .rangeTrading:
            return generateRangeTemplate(customizations)
        case .breakout:
            return generateBreakoutTemplate(customizations)
        case .gridTrading:
            return generateGridTemplate(customizations)
        }
    }
    
    private func generateScalpingTemplate(_ params: [String: Any]) -> String {
        // Scalping template with tight stops and quick exits
        return """
        // Scalping Strategy Template
        // Generated by Pipflow AI
        
        #property strict
        
        input double RiskPercent = 0.5;      // Risk per trade
        input int    StopLoss = 10;         // Stop loss in pips
        input int    TakeProfit = 15;       // Take profit in pips
        input int    MaxSpread = 3;         // Maximum spread
        
        // ... scalping specific code
        """
    }
    
    private func generateTrendingTemplate(_ params: [String: Any]) -> String {
        // Trend following template
        return """
        // Trend Following Strategy Template
        // Generated by Pipflow AI
        
        #property strict
        
        input int    MAPeriod = 50;          // Moving average period
        input double RiskPercent = 1.0;      // Risk per trade
        input bool   UseTrailing = true;    // Use trailing stop
        
        // ... trend following specific code
        """
    }
    
    private func generateRangeTemplate(_ params: [String: Any]) -> String {
        // Range trading template
        return """
        // Range Trading Strategy Template
        // Generated by Pipflow AI
        
        #property strict
        
        input int    RangePeriod = 20;       // Range calculation period
        input double RangeMultiplier = 1.5;  // Range expansion multiplier
        input double RiskPercent = 1.0;      // Risk per trade
        
        // ... range trading specific code
        """
    }
    
    private func generateBreakoutTemplate(_ params: [String: Any]) -> String {
        // Breakout strategy template
        return """
        // Breakout Strategy Template
        // Generated by Pipflow AI
        
        #property strict
        
        input int    LookbackPeriod = 20;    // Lookback period for breakout
        input double BreakoutPips = 5;       // Minimum breakout distance
        input double RiskPercent = 1.5;      // Risk per trade
        
        // ... breakout specific code
        """
    }
    
    private func generateGridTemplate(_ params: [String: Any]) -> String {
        // Grid trading template
        return """
        // Grid Trading Strategy Template
        // Generated by Pipflow AI
        
        #property strict
        
        input double GridStep = 20;          // Grid step in pips
        input int    GridLevels = 10;        // Number of grid levels
        input double LotSize = 0.01;         // Fixed lot size per level
        
        // ... grid trading specific code
        """
    }
}

enum MQL5StrategyTemplate {
    case scalping
    case trending
    case rangeTrading
    case breakout
    case gridTrading
}